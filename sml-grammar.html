<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <title>SML Grammar</title>
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
  <meta name="author" http-equiv="reply-to" content="Andreas Rossberg, rossberg@mpi-sws.org">
  <meta name="description" content="SML grammar">
  <meta name="keywords" content="Standard ML, SML, syntax, grammar, BNF">
</head>

<body _texified="true">


<h1>Standard ML Grammar</h1>

<p>This page describes the full grammar of the core and module language of <a href="http://mitpress.mit.edu/book-home.tcl?isbn=0262631814">Standard ML ('97 revision)</a>, including all "derived forms" from Appendix A of the language definition<!-- (a few minor omissions are noted in the respective sections below)-->.</p>
 
<p>See <a href="#notation">below</a> for explanation of the notation.</p>


<h2><a name="core">Core Language</a></h2>

<h3><a name="con">Constants</a></h3>

<table>
  <tbody><tr>
    <td> <i>con</i> </td>
    <td>::=&nbsp;&nbsp;</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>int</i> </td>
    <td> integer </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>word</i> </td>
    <td> word </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>float</i> </td>
    <td> floating point </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>char</i> </td>
    <td> character </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>string</i> </td>
    <td> string </td>
  </tr>

  <tr>
    <td> <i>int</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> &#10216;<tt>~</tt>&#10217;<i>num</i> </td>
    <td> decimal </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> &#10216;<tt>~</tt>&#10217;<tt>0x</tt><i>hex</i> </td>
    <td> hexadecimal </td>
  </tr>

  <tr>
    <td> <i>word</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <tt>0w</tt><i>num</i> </td>
    <td> decimal </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>0wx</tt><i>hex</i> </td>
    <td> hexadecimal </td>
  </tr>

  <tr>
    <td> <i>float</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> &#10216;<tt>~</tt>&#10217;<i>num</i><tt>.</tt><i>num</i> </td>
    <td> floating point </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> &#10216;<tt>~</tt>&#10217;<i>num</i>&#10216;<tt>.</tt><i>num</i>&#10217;<tt>e</tt>&#10216;<tt>~</tt>&#10217;<i>num</i> &nbsp;&nbsp; </td>
    <td> scientific </td>
  </tr>

  <tr>
    <td> <i>char</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <tt>#"</tt><i>ascii</i><tt>"</tt> </td>
    <td> character </td>
  </tr>

  <tr>
    <td> <i>string</i>&nbsp;&nbsp; </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <tt>"</tt>&#10216;<i>ascii</i>&#10217;*<tt>"</tt> </td>
    <td> string </td>
  </tr>

  <tr>
    <td> <i>num</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> &#10216;<i>digit</i>&#10217;<sup>+</sup> </td>
    <td> number </td>
  </tr>

  <tr>
    <td> <i>hex</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> &#10216;<i>digit</i> | <i>letter</i>&#10217;<sup>+</sup> </td>
    <td> hexadecimal number (letters may only be in the range A-F) </td>
  </tr>

  <tr>
    <td> <i>ascii</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> ... </td>
    <td> single non-<tt>"</tt> ASCII character or <tt>\</tt>-headed escape sequence </td>
  </tr>
</tbody></table>



<h3><a name="id">Identifiers</a></h3>

<table>
  <tbody><tr>
    <td> <i>id</i> </td>
    <td>::=&nbsp;&nbsp;</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>letter</i>&#10216;<i>letter</i> | <i>digit</i> | <tt>'</tt> | <tt>_</tt>&#10217;* </td>
    <td> alphanumeric </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> &#10216;<tt>!</tt> | <tt>%</tt> | <tt>&amp;</tt> | <tt>$</tt> | <tt>#</tt> | <tt>+</tt> | <tt>-</tt> | <tt>/</tt> | <tt>:</tt> | <tt>&lt;</tt> | <tt>=</tt> | <tt>&gt;</tt> | <tt>?</tt> | <tt>@</tt> | <tt>\</tt> | <tt>~</tt> | <tt>`</tt> | <tt>^</tt> | <tt>|</tt> | <tt>*</tt>&#10217;<sup>+</sup> &nbsp;&nbsp;</td>
    <td> symbolic (not allowed for type variables or module language identifiers) </td>
  </tr>

  <tr>
    <td> <i>var</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <tt>'</tt>&#10216;<i>id</i>&#10217; </td>
    <td> unconstrained </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>''</tt>&#10216;<i>id</i>&#10217; </td>
    <td> equality </td>
  </tr>

  <tr>
    <td> <i>longid</i> &nbsp;&nbsp; </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>id</i><sub>1</sub><tt>.</tt>иии<tt>.</tt><i>id</i><sub><i>n</i></sub> </td>
    <td> qualified (<i>n</i> &#8805; 1) </td>
  </tr>

  <tr>
    <td> <i>lab</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>id</i> </td>
    <td> identifier </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>num</i> </td>
    <td> number (may not start with <tt>0</tt>) </td>
  </tr>
</tbody></table>


<h3><a name="exp">Expressions</a></h3>

<table>
  <tbody><tr>
    <td> <i>exp</i> </td>
    <td>::=&nbsp;&nbsp;</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>con</i> </td>
    <td> constant </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> &#10216;<tt>op</tt>&#10217; <i>longid</i> </td>
    <td> value or constructor identifier </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>exp</i><sub>1</sub> <i>exp</i><sub>2</sub> </td>
    <td> application </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>exp</i><sub>1</sub> <i>id</i> <i>exp</i><sub>2</sub> </td>
    <td> infix application </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>(</tt> <i>exp</i> <tt>)</tt> </td>
    <td> parentheses </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>(</tt> <i>exp</i><sub>1</sub> <tt>,</tt> ... <tt>,</tt>
                    <i>exp</i><sub><i>n</i></sub> <tt>)</tt> </td>
    <td> tuple (<i>n</i> &#8800; 1) </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>{</tt> &#10216;<i>exprow</i>&#10217; <tt>}</tt> &nbsp;&nbsp; </td>
    <td> record </td>
 <!--
    <td> <tt>{</tt> <i>lab</i><sub>1</sub> <tt>=</tt> <i>exp</i><sub>1</sub> <tt>,</tt> ... <tt>,</tt>
                    <i>lab</i><sub><i>n</i></sub> <tt>=</tt> <i>exp</i><sub><i>n</i></sub> <tt>}</tt> &nbsp;&nbsp; </td>
    <td> record (<i>n</i> &ge; 0) </td>
-->
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>#</tt> <i>lab</i> </td>
    <td> record selector </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>[</tt> <i>exp</i><sub>1</sub> <tt>,</tt> ... <tt>,</tt>
                    <i>exp</i><sub><i>n</i></sub> <tt>]</tt> </td>
    <td> list (<i>n</i> &#8805; 0) </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>(</tt> <i>exp</i><sub>1</sub> <tt>;</tt> ... <tt>;</tt>
                    <i>exp</i><sub><i>n</i></sub> <tt>)</tt> </td>
    <td> sequence (<i>n</i> &#8805; 2) </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>let</tt> <i>dec</i>
         <tt>in</tt> <i>exp</i><sub>1</sub> <tt>;</tt> ... <tt>;</tt>
                     <i>exp</i><sub><i>n</i></sub> <tt>end</tt> &nbsp;&nbsp; </td>
    <td> local declaration (<i>n</i> &#8805; 1) </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>exp</i> <tt>:</tt> <i>typ</i> </td>
    <td> type annotation </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>raise</tt> <i>exp</i> </td>
    <td> exception raising </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>exp</i> <tt>handle</tt> <i>match</i> </td>
    <td> exception handling </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>exp</i><sub>1</sub> <tt>andalso</tt> <i>exp</i><sub>2</sub> </td>
    <td> conjunction </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>exp</i><sub>1</sub> <tt>orelse</tt> <i>exp</i><sub>2</sub> </td>
    <td> disjunction </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>if</tt> <i>exp</i><sub>1</sub>
         <tt>then</tt> <i>exp</i><sub>2</sub>
         <tt>else</tt> <i>exp</i><sub>3</sub> </td>
    <td> conditional </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>while</tt> <i>exp</i><sub>1</sub>
         <tt>do</tt> <i>exp</i><sub>2</sub> </td>
    <td> iteration </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>case</tt> <i>exp</i> <tt>of</tt> <i>match</i> </td>
    <td> case analysis </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>fn</tt> <i>match</i> </td>
    <td> function </td>
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>exprow</i> &nbsp;&nbsp;</td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>lab</i> <tt>=</tt> <i>exp</i> &#10216;<tt>,</tt> <i>exprow</i>&#10217; </td>
    <td> expression row </td>
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>match</i> &nbsp;&nbsp;</td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>pat</i> <tt>=&gt;</tt> <i>exp</i> &#10216;<tt>|</tt> <i>match</i>&#10217; </td>
    <td> match </td>
<!--
    <td> <i>pat</i><sub>1</sub> <tt>=></tt> <i>exp</i><sub>1</sub> <tt>|</tt> ... <tt>|</tt>
         <i>pat</i><sub><i>n</i></sub> <tt>=></tt> <i>exp</i><sub><i>n</i></sub> </td>
    <td> match (<i>n</i> &ge; 1) </td>
-->
  </tr>
</tbody></table>


<h3><a name="pat">Patterns</a></h3>

<table>
  <tbody><tr>
    <td> <i>pat</i> &nbsp;&nbsp; </td>
    <td>::=&nbsp;&nbsp;</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>con</i> </td>
    <td> constant </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>_</tt> </td>
    <td> wildcard </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> &#10216;<tt>op</tt>&#10217; <i>id</i> </td>
    <td> variable </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> &#10216;<tt>op</tt>&#10217; <i>longid</i> &#10216;<i>pat</i>&#10217; </td>
    <td> construction </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>pat</i><sub>1</sub> <i>id</i> <i>pat</i><sub>2</sub> </td>
    <td> infix construction </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>(</tt> <i>pat</i> <tt>)</tt> </td>
    <td> parentheses </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>(</tt> <i>pat</i><sub>1</sub> <tt>,</tt> ... <tt>,</tt>
                    <i>pat</i><sub><i>n</i></sub> <tt>)</tt> </td>
    <td> tuple (<i>n</i> &#8800; 1) </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>{</tt> &#10216;<i>patrow</i>&#10217; <tt>}</tt> &nbsp;&nbsp; </td>
    <td> record </td>
<!--
    <td> <tt>{</tt> <i>lab</i><sub>1</sub> &lang;<tt>=</tt> <i>pat</i><sub>1</sub>&rang; <tt>,</tt> ... <tt>,</tt>
                    <i>lab</i><sub><i>n</i></sub> &lang;<tt>=</tt> <i>pat</i><sub><i>n</i></sub>&rang; 
                    &lang;<tt>,</tt> <tt>...</tt>&rang; <tt>}</tt> &nbsp;&nbsp; </td>
    <td> record (<i>n</i> &ge; 0) </td>
-->
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>[</tt> <i>pat</i><sub>1</sub> <tt>,</tt> ... <tt>,</tt>
                    <i>pat</i><sub><i>n</i></sub> <tt>]</tt> </td>
    <td> list (<i>n</i> &#8805; 0) </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>pat</i> <tt>:</tt> <i>typ</i> </td>
    <td> type annotation </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> &#10216;<tt>op</tt>&#10217; <i>id</i> &#10216;<tt>:</tt> <i>typ</i>&#10217;
         <tt>as</tt> <i>pat</i> </td>
    <td> layered </td>
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>patrow</i> &nbsp;&nbsp;</td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <tt>...</tt> </td>
    <td> wildcard </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>lab</i> <tt>=</tt> <i>pat</i> &#10216;<tt>,</tt> <i>patrow</i>&#10217; </td>
    <td> pattern </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>id</i> &#10216;<tt>:</tt> <i>typ</i>&#10217;
         &#10216;<tt>as</tt> <i>pat</i>&#10217; &#10216;<tt>,</tt> <i>patrow</i>&#10217; &nbsp;&nbsp;</td>
    <td> variable </td>
  </tr>
</tbody></table>

<!--
<p><sub>Note: Omitted layered patterns on record labels.</sub></p>
-->

<h3><a name="typ">Types</a></h3>

<table>
  <tbody><tr>
    <td> <i>typ</i> &nbsp;&nbsp;</td>
    <td>::=&nbsp;&nbsp;</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>var</i> </td>
    <td> variable </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> &#10216;<i>typ</i>&#10217;<sup>(,)</sup> <i>longid</i> </td>
    <td> constructor </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>(</tt> <i>typ</i> <tt>)</tt> </td>
    <td> parentheses </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>typ</i><sub>1</sub> <tt>-&gt;</tt> <i>typ</i><sub>2</sub> </td>
    <td> function </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>typ</i><sub>1</sub> <tt>*</tt> ... <tt>*</tt>
         <i>typ</i><sub><i>n</i></sub> </td>
    <td> tuple (<i>n</i> &#8805; 2) </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>{</tt> &#10216;<i>typrow</i>&#10217; <tt>}</tt> &nbsp;&nbsp; </td>
    <td> record </td>
<!--
    <td> <tt>{</tt> <i>lab</i><sub>1</sub> <tt>:</tt> <i>typ</i><sub>1</sub> <tt>,</tt> ... <tt>,</tt>
                    <i>lab</i><sub><i>n</i></sub> <tt>:</tt> <i>typ</i><sub><i>n</i></sub> <tt>}</tt> &nbsp;&nbsp;</td>
    <td> record (<i>n</i> &ge; 0) </td>
-->
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>typrow</i> &nbsp;&nbsp;</td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>lab</i> <tt>:</tt> <i>typ</i> &#10216;<tt>,</tt> <i>typrow</i>&#10217; &nbsp;&nbsp;</td>
    <td> type row </td>
  </tr>
</tbody></table>


<h3><a name="dec">Declarations</a></h3>

<table>
  <tbody><tr>
    <td> <i>dec</i> </td>
    <td>::=&nbsp;&nbsp;</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <tt>val</tt> &#10216;<i>var</i>&#10217;<sup>(,)</sup> <i>valbind</i> </td>
    <td> value </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>fun</tt> &#10216;<i>var</i>&#10217;<sup>(,)</sup> <i>funbind</i> </td>
    <td> function </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>type</tt> <i>typbind</i> </td>
    <td> type </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>datatype</tt> <i>datbind</i> &#10216;<tt>withtype</tt> <i>typbind</i>&#10217; </td>
    <td> data type </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>datatype</tt> <i>id</i> <tt>=</tt> <tt>datatype</tt> <i>longid</i> </td>
    <td> data type replication </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>abstype</tt> <i>datbind</i> &#10216;<tt>withtype</tt> <i>typbind</i>&#10217; <tt>with</tt> <i>dec</i> <tt>end</tt> </td>
    <td> abstract type </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>exception</tt> <i>exnbind</i> </td>
    <td> exception </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>structure</tt> <i>strbind</i> </td>
    <td> structure (not allowed inside expressions) </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> </td>
    <td> empty </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>dec</i><sub>1</sub> &#10216;<tt>;</tt>&#10217; <i>dec</i><sub>2</sub> </td>
    <td> sequence </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>local</tt> <i>dec</i><sub>1</sub> <tt>in</tt> <i>dec</i><sub>2</sub> <tt>end</tt> </td>
    <td> local </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>open</tt> <i>longid</i><sub>1</sub> ... <i>longid</i><sub><i>n</i></sub> </td>
    <td> inclusion (<i>n</i> &#8805; 1) </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>nonfix</tt> <i>id</i><sub>1</sub> ... <i>id</i><sub><i>n</i></sub> </td>
    <td> nonfix (<i>n</i> &#8805; 1) </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>infix</tt> &#10216;<i>digit</i>&#10217; <i>id</i><sub>1</sub> ... <i>id</i><sub><i>n</i></sub> </td>
    <td> left-associative infix (<i>n</i> &#8805; 1) </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>infixr</tt> &#10216;<i>digit</i>&#10217; <i>id</i><sub>1</sub> ... <i>id</i><sub><i>n</i></sub> </td>
    <td> right-associative infix (<i>n</i> &#8805; 1) </td>
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>valbind</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>pat</i> <tt>=</tt> <i>exp</i> &#10216;<tt>and</tt> <i>valbind</i>&#10217; </td>
    <td> destructuring </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>rec</tt> <i>valbind</i> </td>
    <td> recursive </td>
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>funbind</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>funmatch</i> &#10216;<tt>and</tt> <i>funbind</i>&#10217; </td>
    <td> clausal function </td>
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>funmatch</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> &#10216;<tt>op</tt>&#10217; <i>id</i> <i>pat</i><sub>1</sub> ... <i>pat</i><sub><i>n</i></sub> &#10216;<tt>:</tt> <i>typ</i>&#10217; <tt>=</tt> <i>exp</i> &#10216;<tt>|</tt> <i>funmatch</i>&#10217; &nbsp;&nbsp;</td>
    <td> nonfix (<i>n</i> &#8805; 1) </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>pat</i><sub>1</sub> <i>id</i> <i>pat</i><sub>2</sub>  &#10216;<tt>:</tt> <i>typ</i>&#10217; <tt>=</tt> <i>exp</i> &#10216;<tt>|</tt> <i>funmatch</i>&#10217; </td>
    <td> infix </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>(</tt> <i>pat</i><sub>1</sub> <i>id</i> <i>pat</i><sub>2</sub>  <tt>)</tt> <i>pat'</i><sub>1</sub> ... <i>pat'</i><sub><i>n</i></sub> &#10216;<tt>:</tt> <i>typ</i>&#10217; <tt>=</tt> <i>exp</i> &#10216;<tt>|</tt> <i>funmatch</i>&#10217; &nbsp;&nbsp; </td>
    <td> infix (<i>n</i> &#8805; 0) </td>
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>typbind</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> &#10216;<i>var</i>&#10217;<sup>(,)</sup> <i>id</i> <tt>=</tt> <i>typ</i> &#10216;<tt>and</tt> <i>typbind</i>&#10217; </td>
    <td> abbreviation </td>
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>datbind</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> &#10216;<i>var</i>&#10217;<sup>(,)</sup> <i>id</i> <tt>=</tt> 
           <i>conbind</i> &#10216;<tt>and</tt> <i>datbind</i>&#10217; &nbsp;&nbsp; </td>
    <td> data type </td>
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>conbind</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>id</i> &#10216;<tt>of</tt> <i>typ</i>&#10217; &#10216;<tt>|</tt> <i>conbind</i>&#10217; &nbsp;&nbsp; </td>
    <td> data constructor </td>
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>exnbind</i>&nbsp;&nbsp; </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>id</i> &#10216;<tt>of</tt> <i>typ</i>&#10217; &#10216;<tt>and</tt> <i>exnbind</i>&#10217; </td>
    <td> generative </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>id</i> <tt>=</tt> <i>longid</i> &#10216;<tt>and</tt> <i>exnbind</i>&#10217; </td>
    <td> renaming </td>
  </tr>
</tbody></table>

<p><sub>Note: Omitted <tt>op</tt> on constructors.</sub></p>



<h3><a name="prog">Programs</a></h3>

<table>
  <tbody><tr>
    <td> <i>prog</i> </td>
    <td>::=&nbsp;&nbsp;</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>dec</i> </td>
    <td> core declaration </td>
  </tr>
<!--
  <tr>
    <td></td> <td></td>
    <td> <i>exp</i> <tt>;</tt> </td>
    <td> expression </td>
  </tr>
-->
  <tr>
    <td></td> <td></td>
    <td> <tt>functor</tt> <i>fctbind</i> </td>
    <td> functor declaration </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <tt>signature</tt> <i>sigbind</i> </td>
    <td> signature declaration </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> </td>
    <td> empty </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>prog</i><sub>1</sub> &#10216;<tt>;</tt>&#10217; <i>prog</i><sub>2</sub> </td>
    <td> sequence </td>
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>fctbind</i> </td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>id</i><sub>1</sub> <tt>(</tt> <i>id</i><sub>2</sub> <tt>:</tt> <i>sig</i> <tt>)</tt> &#10216;<tt>:</tt>&#10216;<tt>&gt;</tt>&#10217; <i>sig</i>&#10217; <tt>=</tt> <i>str</i> &#10216;<tt>and</tt> <i>fctbind</i>&#10217; &nbsp;&nbsp;</td>
    <td> plain </td>
  </tr>
  <tr>
    <td></td> <td></td>
    <td> <i>id</i> <tt>(</tt> <i>spec</i> <tt>)</tt> &#10216;<tt>:</tt>&#10216;<tt>&gt;</tt>&#10217; <i>sig</i>&#10217; <tt>=</tt> <i>str</i> &#10216;<tt>and</tt> <i>fctbind</i>&#10217; </td>
    <td> opened </td>
  </tr>

  <tr><td></td></tr>
  <tr>
    <td> <i>sigbind</i> &nbsp;&nbsp;</td>
    <td>::=</td>
<!--
  </tr>
  <tr>
    <td></td> <td></td>
-->
    <td> <i>id</i> <tt>=</tt> <i>sig</i> &#10216;<tt>and</tt> <i>sigbind</i>&#10217; </td>
    <td> signature </td>
  </tr>
</tbody></table>

<p><sub>Note: Omitted <i>exp</i><tt>;</tt> derived form for interactive toplevel.</sub></p>


<h2><a name="notation">Notation</a></h2>

<p>We liberally use the following notation in the grammar:</p>
<ul>
<!--
<li> <tt>typewriter</tt> font for terminal symbols</li>
-->
<li> &#10216;<i>foo</i>&#10217; for 0 or 1 occurrences of <i>foo</i></li>
<li> &#10216;<i>foo</i>&#10217;* for 0 to many occurrences of <i>foo</i></li>
<li> &#10216;<i>foo</i>&#10217;<sup>+</sup> for 1 to many occurrences of <i>foo</i></li>
<li> &#10216;<i>foo</i> | <i>bar</i>&#10217; for one of <i>foo</i> or <i>bar</i> (also with more alternatives<!--, or iterated with * or <sup>+</sup>-->)</li>
<!--
<li> <i>foo</i><sub>1</sub> <tt>@</tt> ... <tt>@</tt> <i>foo</i><sub><i>n</i></sub> for <i>n</i> occurrences of <i>foo</i>, separated by <tt>@</tt></li>
-->
<li> &#10216;<i>foo</i>&#10217;<sup>(,)</sup> for 0 or 1 occurrences of <i>foo</i>, or 1 to many comma-separated occurrences enclosed in parentheses (i.e., either empty, <i>foo</i>, or <tt>(</tt><i>foo</i><sub>1</sub><tt>,</tt>...<tt>,</tt><i>foo</i><sub><i>n</i></sub><tt>)</tt> for <i>n</i> &#8805; 1)</li>
</ul>


<hr>

<table cellpadding="0" width="100%">
  <tbody><tr>
    <td>
      <a href="http://www.mpi-sws.org/%7Erossberg/">Andreas Rossberg</a>,
      <a href="mailto:rossberg@mpi-sws.org">rossberg@mpi-sws.org</a>. <br>
      Last modified: 2013/04/22
    </td>

    <td align="right">
      <a href="http://validator.w3.org/check?uri=referer">
        <img src="sml-grammar_files/valid-xhtml10-blue.png" alt="Valid XHTML 1.0 Transitional" border="0" height="31" width="88">
      </a>
    </td>
  </tr>
</tbody></table>



</body></html>
